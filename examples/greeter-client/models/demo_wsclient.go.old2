package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"net/url"
	"log"
	"github.com/go-openapi/strfmt"
	apiclient "github.com/elakito/swagsock/examples/greeter-client/client"
	apioperations "github.com/elakito/swagsock/examples/greeter-client/client/operations"
	apimodels "github.com/elakito/swagsock/examples/greeter-client/models"
	"github.com/gorilla/websocket"
	"github.com/go-openapi/runtime"
	runtimeclient "github.com/go-openapi/runtime/client"
	"net/http"
	"time"
	"bytes"
	"strings"
	"os"
	"github.com/elakito/swagsock/swagsock"
	"io"
	"io/ioutil"
)

//
// This is not the final picture of wsclient but demonstrates how the greeter requests can be sent over websocket and
// gives a hint to how it can be integrated to the current client that only supports http.
//
func main() {
	target_path := flag.String("target_path", "ws://localhost:8091/samples/greeter", "target_path")
	flag.Parse()

	u, err := url.Parse(*target_path)
	if err != nil {
		log.Fatalf("failed to parse the target url %s: %v", *target_path, err)
	}
	//transport := httpclient.New(u.Host, u.Path, []string{u.Scheme})
	transport := newWSTransport(u.String())
	defer transport.Close()

	// create the API client, with the transport
	client := newWSClient(transport, strfmt.Default)
	fmt.Printf("demo_client invoking some operations at target_path %s ...\n", *target_path)

	// ping
	pingOK, err := client.Operations.Ping(nil)
	if err != nil {
		log.Fatalf("failed to invoke: %v", err)
	}

	// print out the json representaiton of the pong object
	jsonpayload, _ := json.Marshal(pingOK.Payload)
	fmt.Printf("Ping-Response: %s\n", jsonpayload)

	// echo
	echoBody := "hi"
	echoParams := apioperations.NewEchoParams().WithBody(&echoBody)
	echoOK, err := client.Operations.Echo(echoParams)
	if err != nil {
		log.Fatalf("failed to invoke: %v", err)
	}
	jsonpayload, _ = json.Marshal(echoOK.Payload)
	fmt.Printf("Echo-Response: %s\n", jsonpayload)

	// greet
	greetBody := &apimodels.Body{Name: "foo", Text: "hola"}
	greetParams := apioperations.NewGreetParams().WithName("bar").WithBody(greetBody)
	greetOK, err := client.Operations.Greet(greetParams)
	if err != nil {
		log.Fatalf("failed to invoke: %v", err)
	}
	jsonpayload, _ = json.Marshal(greetOK.Payload)
	fmt.Printf("Greet-Response: %s\n", jsonpayload)

	// greetStatus
	getGreetStatusParams := apioperations.NewGetGreetStatusParams().WithName("bar")
	getGreetStatusOK, err := client.Operations.GetGreetStatus(getGreetStatusParams)
	if err != nil {
		log.Fatalf("failed to invoke: %v", err)
	}
	jsonpayload, _ = json.Marshal(getGreetStatusOK.Payload)
	fmt.Printf("GetGreetStatus-Response: %s\n", jsonpayload)

	// greetSummary
	getGreetSummaryOK, err := client.Operations.GetGreetSummary(nil)
	if err != nil {
		log.Fatalf("failed to invoke: %v", err)
	}
	jsonpayload, _ = json.Marshal(getGreetSummaryOK.Payload)
	fmt.Printf("GetGreetSummary-Response: %s\n", jsonpayload)
}

//
func newWSClient(transport *wstransport, formats strfmt.Registry) *apiclient.GreeterDemo {
	cli := new(apiclient.GreeterDemo)
	cli.Operations = apioperations.New(transport, formats)
	return cli
}

func newWSTransport(url string) *wstransport {
	t := &wstransport{url: url, codec: swagsock.NewDefaultCodec(), delivery: make(chan *response, 10)}
	// TODO consolidate the client runtime properties
	t.consumers = map[string]runtime.Consumer{
		runtime.JSONMime:    runtime.JSONConsumer(),
		runtime.XMLMime:     runtime.XMLConsumer(),
		runtime.TextMime:    runtime.TextConsumer(),
		runtime.DefaultMime: runtime.ByteStreamConsumer(),
	}
	t.producers = map[string]runtime.Producer{
		runtime.JSONMime:    runtime.JSONProducer(),
		runtime.XMLMime:     runtime.XMLProducer(),
		runtime.TextMime:    runtime.TextProducer(),
		runtime.DefaultMime: runtime.ByteStreamProducer(),
	}

	t.connect()
	return t
}

type wstransport struct {
	url string
	codec swagsock.Codec
	conn *websocket.Conn
	consumers  map[string]runtime.Consumer
	producers  map[string]runtime.Producer

	delivery chan *response
}

func (t *wstransport) connect() error {
	c, _, err := websocket.DefaultDialer.Dial(t.url, nil)
	t.conn = c
	go func() {
		for {
			_, message, err := t.conn.ReadMessage()
			if err == nil {
				headers, body, err := t.codec.DecodeSwaggerSocketMessage(message)
				if err == nil {
					res := &response{code: headers["code"].(int)}
					if mediaType, found := headers["type"].(string); found {
						res.mediaType = mediaType
					}
					if len(body) > 0 {
						res.body = ioutil.NopCloser(bytes.NewBuffer(body))
					}
					t.delivery <- res
				} else {
					log.Printf("### ignoring a non-swagsock message: %s", message)
				}
			} else {
				log.Println("Error read:", err)
				return
			}
		}
	}()

	return err
}

func (t *wstransport) Submit(operation *runtime.ClientOperation) (interface{}, error) {
	req := &request{
		pathPattern: operation.PathPattern,
		method:      operation.Method,
		writer:      operation.Params,
		header:      make(http.Header),
		query:       make(url.Values),
		timeout:     runtimeclient.DefaultTimeout,
	}

	// build the data
	if err := req.writer.WriteToRequest(req, strfmt.Default); err != nil {
		return nil, err
	}

	rawpath := operation.PathPattern
	for k, v := range req.pathParams {
		rawpath = strings.Replace(rawpath, "{"+k+"}", url.PathEscape(v), -1)
	}
	rawquery := req.query.Encode()
	if rawquery != "" {
		rawpath = fmt.Sprintf("%s?%s", rawpath, rawquery)
	}
	body := ""
	if req.payload != nil {
		body = *(req.payload.(*string))
	}
	text := fmt.Sprintf(`{ "id": "%s", "method": "%s", "path": "%s"}%s`,
		"123", operation.Method, rawpath, body)
	fmt.Printf("#### submit message=%s\n", text)
	t.conn.WriteMessage(websocket.TextMessage, []byte(text))

	response := <- t.delivery
	fmt.Printf("##### response: %v\n", response)
	cons, ok := t.consumers[response.mediaType]
	if !ok {
		// scream about not knowing what to do
		return nil, fmt.Errorf("no consumer: %q", response.mediaType)
	}
	return operation.Reader.ReadResponse(response, cons)
}

func (t *wstransport) Close() {
	fmt.Printf("##### wstransport.Close\n")
	t.conn.Close()
}

type response struct {
	code int
	message string
	mediaType string
	body io.ReadCloser
}

func (r response) Code() int {
	return r.code
}

func (r response) Message() string {
	return r.message
}

func (r response) GetHeader(name string) string {
	return ""
}

func (r response) Body() io.ReadCloser {
	return r.body
}

type futureResponse struct {

}

func (m *futureResponse) Get(timeout time.Duration) (*response, error) {
	return nil, nil
}

// a copy of the package private runtime.request (used now until figuring out how everything can be integrated)
//////////////////// DO NOT EDIT THIS PART
type request struct {
	pathPattern string
	method      string
	writer      runtime.ClientRequestWriter

	pathParams map[string]string
	header     http.Header
	query      url.Values
	formFields url.Values
	fileFields map[string][]runtime.NamedReadCloser
	payload    interface{}
	timeout    time.Duration
	buf        *bytes.Buffer
}

func (r *request) GetMethod() string {
	return r.method
}

func (r *request) GetPath() string {
	path := r.pathPattern
	for k, v := range r.pathParams {
		path = strings.Replace(path, "{"+k+"}", v, -1)
	}
	return path
}

func (r *request) GetBody() []byte {
	if r.buf == nil {
		return nil
	}
	return r.buf.Bytes()
}

// SetHeaderParam adds a header param to the request
// when there is only 1 value provided for the varargs, it will set it.
// when there are several values provided for the varargs it will add it (no overriding)
func (r *request) SetHeaderParam(name string, values ...string) error {
	if r.header == nil {
		r.header = make(http.Header)
	}
	r.header[http.CanonicalHeaderKey(name)] = values
	return nil
}

// SetQueryParam adds a query param to the request
// when there is only 1 value provided for the varargs, it will set it.
// when there are several values provided for the varargs it will add it (no overriding)
func (r *request) SetQueryParam(name string, values ...string) error {
	if r.query == nil {
		r.query = make(url.Values)
	}
	r.query[name] = values
	return nil
}

// GetQueryParams returns a copy of all query params currently set for the request
func (r *request) GetQueryParams() url.Values {
	var result = make(url.Values)
	for key, value := range r.query {
		result[key] = append([]string{}, value...)
	}
	return result
}

// SetFormParam adds a forn param to the request
// when there is only 1 value provided for the varargs, it will set it.
// when there are several values provided for the varargs it will add it (no overriding)
func (r *request) SetFormParam(name string, values ...string) error {
	if r.formFields == nil {
		r.formFields = make(url.Values)
	}
	r.formFields[name] = values
	return nil
}

// SetPathParam adds a path param to the request
func (r *request) SetPathParam(name string, value string) error {
	if r.pathParams == nil {
		r.pathParams = make(map[string]string)
	}

	r.pathParams[name] = value
	return nil
}

// SetFileParam adds a file param to the request
func (r *request) SetFileParam(name string, files ...runtime.NamedReadCloser) error {
	for _, file := range files {
		if actualFile, ok := file.(*os.File); ok {
			fi, err := os.Stat(actualFile.Name())
			if err != nil {
				return err
			}
			if fi.IsDir() {
				return fmt.Errorf("%q is a directory, only files are supported", file.Name())
			}
		}
	}

	if r.fileFields == nil {
		r.fileFields = make(map[string][]runtime.NamedReadCloser)
	}
	if r.formFields == nil {
		r.formFields = make(url.Values)
	}

	r.fileFields[name] = files
	return nil
}

// SetBodyParam sets a body parameter on the request.
// This does not yet serialze the object, this happens as late as possible.
func (r *request) SetBodyParam(payload interface{}) error {
	r.payload = payload
	return nil
}

// SetTimeout sets the timeout for a request
func (r *request) SetTimeout(timeout time.Duration) error {
	r.timeout = timeout
	return nil
}
//////////////////// DO NOT EDIT END